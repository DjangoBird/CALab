# 2025.10.31 王谊康
## 编写csr.v
主要就是照着教材内容对各个寄存器的相应的域进行赋值。（不过理解还不是很深刻，后面得添加写注释，可能会有点错误）

## 中断相关信号在各流水级的交互
### IF流水级
IF流水级的取值需要做出调整，从WB流水级会传来异常处理触发信号**wb_ex**和冲刷信号**ertn_flush**,需要根据这两个信号设置**allow_in**和**nextpc**，所以还需要输入异常处理地址**ex_entry**和**ertn_entry**。
```verilog
assign fs_allowin   = !fs_valid | (fs_ready_go && ds_allowin) | ertn_flush |wb_ex;//冲刷和WB处理异常时不能取值
```
```verilog
assign nextpc = wb_ex ? ex_entry:
                ertn_flush ? ertn_entry:
                br_taken ? br_target : seq_pc;//异常 or 冲刷 or 跳转 or 顺序
```

### ID流水级
ID流水级需要添加状态寄存器相关指令和syscall的译码，取得状态寄存器的相关操作数，并需要向后传递状态寄存器操作数，异常相关信息(syscall,ertn)。
**wb_ex**为1时，数据无效，valid设为0。
<font color="#ff0000">ID流水记得阻塞判断逻辑需要完善，要看exe，mem控制寄存器的操作（教材P186，还没想太明白）。</font>

### EXE流水级
**data_sram**在异常时不能访问，要修改使能信号。精确异常，看EXE，MEM，WB是否有异常发生。
*（store 指令若想在执行级发出写命令，那么需要检查当前访存级和写回级上是否存在已标记为异常或可能标记为异常的指令，也要检查自己有没有产生异常或标记异常。）*
**wb_ex**为1时，数据无效，valid设为0。
继续传递异常相关信息。

### MEM流水级
**wb_ex**为1时，数据无效，valid设为0。
继续传递异常相关信息。


### WB流水级
异常的放在wb流水级集中处理。
**wb_ex**为1时，数据无效，valid设为0。
**wb_ex=inst_syscall, ertn_flush=inst_ertn**
把之前流水级传递过来的异常相关操作数给到csr模块，**ecode**和**esubcode**也给到csr。

## 顶层接口
其实各流水线之间的传递没写完，所以顶层接口还是缺失的。
## 进度
只是把各个流水级之间传递的ex信号添加到module里面了。
if流水级应该差不多。
id流水级还没写阻塞，还没有添加译码逻辑，向后传递异常相关的信号和状态寄存器操作数还没写（可以打包传递，写代码方便一些）。
exe，mem，wb流水级也都还没修改。

<font color="#ff0000">各位有什么补充的想法，建议或者修正可以写在这里面，方便交流。平时写代码的思路什么也可以记下来，写实验报告的时候思路更清晰一些，验收的时候也可以看看。</font>

# 2025.11.01 王谊康
### ID流水级
添加了译码逻辑，修改了和csr相关的冲突阻塞(用的回传的csr_re，不过看书说这个信号其实可以不需要，这点没搞明白，大概就是说某条指令操作数来自csr），修改了need_r1,need_r2逻辑。
ds_ex_zip把csr_we,csr_wmask,csr_wvalue,csr_num,inst_syscall,inst_ertn打包向后传递。

## EXE流水级
根据exe,mem,wb是否异常来设定data_we。继续传递异常信号。

## MEM流水级
继续传递异常信号。

## WB流水级
接受传递过来的异常信号zip后，接触需要给到csr信号。

## 进度
在第一条syscall出了问题，没太理清楚加了异常后该怎么判断是否阻塞，现在的valid,ready_go,allowin等信号没搞清楚。然后就是看书上csr_re其实不需要，感觉我想写的是res_from_csr的意思，但没搞明白。


